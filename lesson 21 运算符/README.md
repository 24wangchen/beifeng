## 算术运算符

JavaScript提供9个算术运算符。

- **加法运算符**（Addition）：x + y

- **减法运算符**（Subtraction）： x - y

- **乘法运算符**（Multiplication）： x * y

- **除法运算符**（Division）：x / y

- **余数运算符**（Remainder）：x % y

- **自增运算符**（Increment）：++x 或者 x++

- **自减运算符**（Decrement）：--x 或者 x--

- **求负运算符**（Negate）：-x

- **数值运算符**（Convert to number）： +x

### 加法运算符

加法运算符（+）需要注意的地方是，它除了用于数值的相加，还能用于字符串的连接。

```javascript

1 + 1 // 2
"1" + "1" // "11"

```

两个运算子之中只要有一个是字符串，加法运算符号就会变为字符串连接运算符，返回连接后的字符串，其他情况则是返回数值相加的和。这种由于参数不同，而改变自身行为的现象，叫做“重载”（overload）。

```javascript

1 + "1" // "11"

```

上面代码表示，两个运算子之中有一个是字符串，另一个运算子就会被自动转为字符串。

```javascript

"3" + 4 + 5 // "345"
3 + 4 + "5" // "75"

```

上面代码中，由于加法运算符遇到字符串，会发生重载，导致运算结果的不同。

由于这个特性，下面的写法有时用于将一个值转为字符串。

```javascript

x + ""

```

上面代码表示，一个值加上空字符串，会使得该值转为字符串形式。

布尔值和复合类型的值，也可以使用加法运算符，但是会导致数据类型的自动转换，关于这方面的详细讨论，参见《数据类型转换》一节。

加法运算符以外的其他算术运算符，都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。

```javascript

1 - "1" // 0
+"3" // 3
-true // -1

```

上面代码表示，减法运算符将字符串“1”自动转为数值1，数值运算符（+）将字符串“3”转为数值3，求负运算符（-）将布尔值true转为-1。

由于加法运算符与其他算术运算符的这种差异，会导致一些意想不到的结果，计算时要小心。

```javascript

var now = new Date();
typeof (now + 1) // "string"
typeof (now - 1) // "number"

```

上面代码中，now是一个Date对象的实例。加法运算时，now转为字符串，加一个数字，得到还是字符串；减法运算时，now转为数值，减一个数字，得到的是数字。

### 余数运算符

余数运算符返回前一个运算子被后一个运算子除，所得的余数。

```javascript

12 % 5 // 2

```

需要注意的是，运算结果的正负号由第一个运算子的正负号决定。

```javascript

-1 % 2 // -1
1 % -2 // 1

```

为了得到正确的负数的余数值，需要先使用绝对值函数。

```javascript

// 错误的写法
function isOdd(n) {
    return n % 2 === 1;
}
isOdd(-5) // false
isOdd(-4) // false

// 正确的写法
function isOdd(n) {
    return Math.abs(n % 2) === 1;
}
isOdd(-5) // true
isOdd(-4) // false

```

余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。

```javascript

6.5 % 2.1 
// 0.19999999999999973

```

### 自增和自减运算符

自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。

```javascript

var x = "1";
++x // 2

```

上面代码的x是一个字符串，使用递增运算符后，x首先被转为数值1，然后进行递增，返回2。

它们有一个需要注意的地方，就是放在变量之后，表示先返回变量操作前的值，再进行递增/递减操作；放在变量之前，表示先进行递增/递减操作，再返回变量操作后的值。

```javascript

var x1 = 1;
var x2 = 1;

x1++ // 1
++x2 // 2

```

上面代码中，x1是先返回后递增，所以得到1；x2是先递增后返回，所以得到2。

### 数值运算符

数值运算符（+）同样使用加号，但是加法运算符是二元运算符（需要两个操作数），它是一元运算符（只需要一个操作数）。

它的重要作用在于可以将任何值转为数值（与Number函数的作用相同）。

```javascript

+true // 1
+[] // 0
+{} // NaN

```

上面代码表示，非数值类型的值经过数值运算符以后，都变成了数值（包括最后一个NaN）。具体的类型转换规则，参见《数据类型转换》一节。

求负运算符（-），也同样具有将一个值转为数值的功能，所以下面的写法等同于求值运算符。

```javascript

-(-x)

```

上面代码的圆括号不可少，否则会变成递减运算符。

## 赋值运算符

赋值运算符（Assignment Operators）用于给变量赋值。

最常见的赋值运算符，当然就是等号（=），表达式`x=y`表示将y赋值给x。除此之外，JavaScript还提供其他11个赋值运算符。

```javascript

x += y // 等同于 x = x + y
x -= y // 等同于 x = x - y
x *= y // 等同于 x = x * y
x /= y // 等同于 x = x / y
x %= y // 等同于 x = x % y
x >>= y // 等同于 x = x >> y
x <<= y // 等同于 x = x << y
x >>>= y // 等同于 x = x >>> y
x &= y // 等同于 x = x & y
x |= y // 等同于 x = x | y
x ^= y // 等同于 x = x ^ y

```

## 比较运算符

比较运算符比较两个值，然后返回一个布尔值，表示是否满足比较条件。JavaScript提供了8个比较运算符。

- **==** 相等
- **===** 严格相等
- **!=** 不相等
- **!==** 严格不相等
- **<** 小于
- **<=** 小于或等于
- **\>** 大于
- **\>=** 大于或等于

其中，比较两个值是否相等的运算符有两个：一个是相等运算符（==），另一个是严格相等运算符（===）。

相等运算符（==）比较两个“值”是否相等，严格相等运算符（===）比较它们是否为“同一个值”。两者的一个重要区别是，如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转化成同一个类型，再用严格相等运算符进行比较。

我们先看严格相等运算符。

### 严格相等运算符

严格相等运算符的运算规则如下：

**（1）不同类型的值**

如果两个值的类型不同，直接返回false。

```javascript

1 === "1" // false

true === "true" // false

```

上面代码比较数值的1与字符串的“1”、布尔值的true与字符串“true”，因为类型不同，结果都是false。

**（2）同一类的原始类型值**

同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。

```javascript

1 === 0x1 // true

```

上面代码比较十进制的1与十六进制的1，因为类型和值都相同，返回true。

需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。

```javascript

NaN === NaN  // false

+0 === -0 // true

```

**（3）同一类的复合类型值**

两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。

```javascript

({}) === {} // false

[] === [] // false

(function (){}) === function (){} // false

```

上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是它们的内存地址是否一样，而上面代码中空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false。另外，之所以要把第一个空对象放在括号内，是为了避免JavaScript引擎把这一行解释成代码块，从而报错；把第一个空函数放在括号内，是为了避免这一行被解释成函数的定义。

如果两个变量指向同一个复合类型的数据，则它们相等。

```javascript

var v1 = {};
var v2 = v1;

v1 === v2 // true

```

**（4）undefined和null**

undefined 和 null 与自身严格相等。

```javascript

undefined === undefined // true

null === null // true

```

由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。

```javascript

var v1;
var v2;

v1 === v2 // true

```

**（5）严格不相等运算符**

严格相等运算符有一个对应的“严格不相等运算符”（!==），两者的运算结果正好相反。

```javascript

1 !== "1" // true

```

### 相等运算符

相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。

在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下：

**（1）原始类型的值**

原始类型的数据会转换成数值类型再进行比较。

```javascript

1 == true // true
0 == false // true

"true" == true // false

'' == 0 // true

'' == false  // true
'1' == true  // true

"2" == true // false
2 == true // false
2 == false // false

'\n  123  \t' == 123 // true
// 因为字符串转为数字时，省略前置和后置的空格

```

上面代码将字符串和布尔值都转为数值，然后再进行比较。字符串与布尔值的类型转换规则，参见《数据类型转换》一节。

**（2）对象与原始类型值比较**

对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。

```javascript

[1] == 1 // true
[1] == "1" // true
[1] == true // true

```

上面代码将只含有数值1的数组与原始类型的值进行比较，数组[1]会被自动转换成数值1，因此结果都是true。数组的类型转换规则，参见《数据类型转换》一节。

**（3）undefined和null**

undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。

```javascript

false == null // false
0 == null // false

undefined == null // true

```

**（4）相等运算符的缺点**

相等运算符隐藏的类型转换，会带来一些违反直觉的结果。

```javascript

'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true

```

上面这些表达式都很容易出错，因此不要使用相等运算符（==），最好只使用严格相等运算符（===）。

**（5）不相等运算符**

相等运算符有一个对应的“不相等运算符”（!=），两者的运算结果正好相反。

```javascript

1 != "1" // false

```

## 布尔运算符

布尔运算符用于将表达式转为布尔值。

### 取反运算符（!）

取反运算符形式上是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true。

```javascript

!true // false
!false // true

```

对于非布尔值的数据，取反运算符会自动将其转为布尔值。规则是，以下六个值取反后为true，其他值取反后都为false。

- undefined
- null
- false
- 0（包括+0和-0）
- NaN
- 空字符串（""）

这意味着，取反运算符有转换数据类型的作用。

```javascript

!undefined // true
!null // true
!0 // true
!NaN // true
!"" // true

!54 // false
!'hello' // false
![] // false
!{} // false

```

上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。

如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。

```javascript

!!x

// 等同于

Boolean(x)

```

上面代码中，不管x是什么类型的值，经过两次取反运算后，变成了与Boolean函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。

取反运算符的这种将任意数据自动转为布尔值的功能，对下面三种布尔运算符（且运算符、或运算符、三元条件运算符）都成立。

### 且运算符（&&）

且运算符的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。

```javascript

"t" && "" // ""
"t" && "f" // "f"
"t" && (1+2) // 3
"" && "f" // ""
"" && "" // ""

var x = 1;
(1-1) && (x+=1) // 0
x // 1

```

上面代码的最后一部分表示，由于且运算符的第一个运算子的布尔值为false，则直接返回它的值0，而不再对第二个运算子求值，所以变量x的值没变。

这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写。

```javascript

if (i !== 0 ){
    doSomething();
}

// 等价于

i && doSomething();

```

上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。

且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。

```javascript

true && 'foo' && '' && 4 && 'foo' && true
// ''

```

上面代码中第一个布尔值为false的表达式为第三个表达式，所以得到一个空字符串。

### 或运算符（||）

或运算符的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。

```javascript

"t" || "" // "t"
"t" || "f" // "t"
"" || "f" // "f"
"" || "" // ""

```

短路规则对这个运算符也适用。

或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。

```javascript

false || 0 || '' || 4 || 'foo' || true
// 4

```

上面代码中第一个布尔值为true的表达式是第四个表达式，所以得到数值4。

或运算符常用于为一个变量设置默认值。

```javascript

function saveText(text) {
    text = text || '';
    // ...
}

// 或者写成

saveText(this.text||'')

```

上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。

### 三元条件运算符（ ? :）

三元条件运算符用问号（？）和冒号（：），分隔三个表达式。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。

```javascript

"t" ? true : false // true

0 ? true : false // false

```

上面代码的“t”和0的布尔值分别为true和false，所以分别返回第二个和第三个表达式的值。

通常来说，三元条件表达式与if...else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else。

```javascript

var check = true ? console.log('T') : console.log('F');

console.log(true ? 'T' : 'F');

```

上面代码是赋值语句和console.log方法的例子，它们都需要使用表达式，这时三元条件表达式就能满足需要。如果要用if...else语句，就必须改变整个代码写法了。


## 其他运算符

### 圆括号运算符

在JavaScript中，圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。

把表达式放在圆括号之中，将返回表达式的值。

```javascript

(1) // 1
('a') // a
(1+2) // 3

```

把对象放在圆括号之中，则会返回对象的值，即对象本身。

```javascript

var o = {p:1};

(o)
// Object {p: 1}

```

将函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数，即对函数求值。

```javascript

function f(){return 1;}

(f) // function f(){return 1;}
f() // 1

```

上面的代码先定义了一个函数，然后依次将函数放在圆括号之中、将圆括号跟在函数后面，得到的结果是不一样的。

由于圆括号的作用是求值，如果将语句放在圆括号之中，就会报错，因为语句没有返回值。

```javascript

(var a =1)
// SyntaxError: Unexpected token var

```

### void运算符

void运算符的作用是执行一个表达式，然后返回undefined。

```javascript

void 0 // undefined
void (0) // undefined

```

上面是void运算符的两种写法，都正确。建议采用后一种形式，即总是使用括号。因为void运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，void 4+7 实际上等同于 (void 4) +7 。

下面是void运算符的一个例子。

```javascript

var x = 3;
void (x = 5) //undefined
x // 5

```

这个运算符主要是用于书签工具（bookmarklet）或者用于在超级链接中插入代码，目的是返回undefined可以防止网页跳转。

```javascript

javascript:void window.open("http://example.com/")

```

比如，下面是常用于网页链接的触发鼠标点击事件的写法。

```javascript

<a href="#" onclick="f();">文字</a>

```

上面代码有一个问题，函数f必须返回false，或者onclick事件必须返回false，否则会引起浏览器跳转到另一个页面。

```javascript

function f(){
    // some code
    return false;
}

```

或者写成

```javascript

<a href="#" onclick="f();return false;">文字</a>

```

void运算符可以取代上面两种写法。

```javascript

<a href="javascript:void(0)" onclick="f();">文字</a>

```

### 逗号运算符

逗号运算符用于对两个表达式求值，并返回后一个表达式的值。

```javascript

"a", "b" // "b"

var x = 0;
var y = (x++, 10);
x // 1
y // 10

```

## 运算顺序

**（1）运算符的优先级**

JavaScript各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。

```javascript

4+5*6 // 34

```

上面的代码中，乘法运算符（*）的优先性高于加法运算符（+），所以先执行乘法，再执行加法，相当于下面这样。

```javascript

4+(5*6) // 34

```

**（2）圆括号的作用**

圆括号可以用来提高运算的优先级，即圆括号中的运算符会第一个运算。

```javascript

(4+5)*6 // 54

```

上面代码中，由于使用了圆括号，加法会先于乘法执行。

由于运算符的优先级别十分繁杂，且都是来自硬性规定，所以本书不打算列出具体的规则，只是建议读者总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。

```javascript

5 + 2 * 4 / 2 % 3 + 10 - 3 

total = 5;
total *= 2 + 3

```

上面代码的运算顺序，就不容易一眼看出来，容易导致错误，应该加上圆括号帮助阅读。

**（3）左结合与右结合**

对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的“左结合”（left-to-right associativity），即从左边开始计算。

```javascript

x + y + z

```

上面代码先计算最左边的x与y的和，然后再计算与z的和。

但是少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的“右结合”（right-to-left associativity）。其中，最主要的是赋值运算符（=）和三元条件运算符（?:）。

```javascript

w = x = y = z;
q = a?b:c?d:e?f:g;

```

上面代码的运算结果，相当于下面的样子。

```javascript

w = (x = (y = z)); 
q = a?b:(c?d:(e?f:g));

```
